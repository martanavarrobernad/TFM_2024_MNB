import random
import time
import datetime
import psychopy
import pandas as pd
from psychopy import visual, core, event
import os
#import pyxid2

# Configuración de la ventana
win = visual.Window(size=(800, 600), color=(1, 1, 1), units="pix", fullscr=False)

# Configuración del dispositivo para triggers
#devices = pyxid2.get_xid_devices()
#if len(devices) == 0:
#    raise RuntimeError("No se encontró ningún dispositivo XID.")
#dev = devices[0]  # Seleccionar el primer dispositivo
#dev.set_pulse_duration(300)  # Configurar duración del pulso en milisegundos

# Lista para almacenar datos de la tarea
datos_ensayo = []
datos_principales = []

# Función para verificar si se ha presionado "escape" para salir y guardar los datos
def check_exit():
    if "escape" in event.getKeys():
        print("Cerrando la tarea...")
        guardar_datos()
        win.close()
        core.quit()

# Función para guardar datos en un archivo CSV
def guardar_datos():
    carpeta_resultados = r"C:\Users\navar\Desktop\tarea tfm\data_reversal"
    if not os.path.exists(carpeta_resultados):
        os.makedirs(carpeta_resultados)
    # Buscar el siguiente nombre de archivo disponible para ambos archivos
    i = 1
    while os.path.exists(os.path.join(carpeta_resultados, f"entrenamiento_sujeto{i:02d}.csv")) or os.path.exists(os.path.join(carpeta_resultados, f"tarea_sujeto{i:02d}.csv")):
        i += 1

    nombre_archivo_entrenamiento = os.path.join(carpeta_resultados, f"entrenamiento_sujeto{i:02d}.csv")
    nombre_archivo_tarea = os.path.join(carpeta_resultados, f"tarea_sujeto{i:02d}.csv")

    # Guardar el dataframe de entrenamiento en el archivo CSV
    if datos_ensayo:
        df_entrenamiento = pd.DataFrame(datos_ensayo, columns=["Fecha", "Expname", "Version PsychoPy", "Refresh Rate", "Frame Rate", "Exp Start",
                                                               "Participante", "Edad", "Imagen", "Inicio Fijación (ms)", "Fin Fijación (ms)",
                                                               "Inicio Imagen (ms)", "Fin Imagen (ms)", "Inicio Feedback (ms)", "Fin Feedback (ms)",
                                                               "Tecla pulsada", "Milisegundo de respuesta", "Tiempo de respuesta",
                                                               "correct", "Feedback", "Tipo de Asociación", "Go/No-Go", "Tecla Registrada", "Congruente"])
        df_entrenamiento.to_csv(nombre_archivo_entrenamiento, index=False)

    # Guardar el dataframe de tarea en el archivo CSV
    if datos_principales:
        df_tarea = pd.DataFrame(datos_principales, columns=["Fecha", "Expname", "Version PsychoPy", "Refresh Rate", "Frame Rate", "Exp Start",
                                                             "Participante", "Edad", "Imagen", "Inicio Fijación (ms)", "Fin Fijación (ms)",
                                                             "Inicio Imagen (ms)", "Fin Imagen (ms)", "Inicio Feedback (ms)", "Fin Feedback (ms)",
                                                             "Tecla pulsada", "Milisegundo de respuesta", "Tiempo de respuesta",
                                                             "correct", "Feedback", "Tipo de Asociación", "Go/No-Go", "Tecla Registrada", "Congruente"])
        df_tarea.to_csv(nombre_archivo_tarea, index=False)

# Función para pedir datos al usuario
def get_input(prompt_text):
    input_text = ""
    text_stim = visual.TextStim(win, text=prompt_text, color=(-1, -1, -1), height=30, pos=(0, 50))
    input_stim = visual.TextStim(win, text="_", color=(-1, -1, -1), height=30, pos=(0, -50))

    while True:
        text_stim.draw()
        input_stim.text = input_text + "_"
        input_stim.draw()
        win.flip()

        keys = event.waitKeys()
        for key in keys:
            if key == "space" and input_text:
                return input_text
            elif key == "backspace":
                input_text = input_text[:-1]
            elif key in "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ":
                input_text += key
            elif key == "escape":
                print("Cerrando la tarea...")
                guardar_datos()
                win.close()
                core.quit()

# Preguntar por el nombre y la edad
nombre = get_input("Escribe tu nombre y presiona la barra espaciadora:")
edad = get_input("Escribe tu edad y presiona la barra espaciadora:")

# Confirmación antes de comenzar
confirm_text = visual.TextStim(win, text=f"¡Bienvenido {nombre}!\nEdad: {edad}\nPresiona Enter para comenzar.",
                               color=(-1, -1, -1), height=30)
confirm_text.draw()
win.flip()
if "escape" in event.waitKeys(keyList=["return", "escape"]):
    check_exit()

# Lista de imágenes para mostrar inicialmente
imagenes_introductorias = [
    r"C:\Users\navar\Desktop\tarea tfm\reversal\Copia de INHIBICIÓN COGNITIVA\1.jpg",
    r"C:\Users\navar\Desktop\tarea tfm\reversal\Copia de INHIBICIÓN COGNITIVA\2.jpg",
    r"C:\Users\navar\Desktop\tarea tfm\reversal\Copia de INHIBICIÓN COGNITIVA\3.jpg"
]

def mostrar_imagenes_iniciales(imagenes):
    """
    Muestra las imágenes de introducción, esperando que el usuario presione la barra espaciadora
    para pasar a la siguiente imagen.
    """
    for imagen in imagenes:
        imagen_stim = visual.ImageStim(win, image=imagen)
        imagen_stim.draw()
        win.flip()
        # Esperar hasta que se presione la barra espaciadora
        if "escape" in event.waitKeys(keyList=["space", "escape"]):
            check_exit()

# Función para verificar si se ha presionado "escape" para salir
def check_exit():
    if "escape" in event.getKeys():
        print("Cerrando la tarea...")
        win.close()
        core.quit()

# Definir la cruz de fijación
fixation = visual.TextStim(win, text="+", color=(-1, -1, -1), height=40)
# Definir el estímulo de la imagen
imagen_stim = visual.ImageStim(win)
# Definir el estímulo de feedback
feedback_stim = visual.TextStim(win, text="", color=(-1, -1, -1), height=40)

# Lista de imágenes a buscar
imagenes = [
    r"C:\Users\navar\Desktop\tarea tfm\habitual_inhibition\E.jpg",
    r"C:\Users\navar\Desktop\tarea tfm\habitual_inhibition\F.jpg",
    r"C:\Users\navar\Desktop\tarea tfm\habitual_inhibition\fbE.jpg",
    r"C:\Users\navar\Desktop\tarea tfm\habitual_inhibition\A.jpg",
    r"C:\Users\navar\Desktop\tarea tfm\habitual_inhibition\B.jpg",
    r"C:\Users\navar\Desktop\tarea tfm\habitual_inhibition\C.jpg"
]

# Diccionario con la proporción de feedback congruente por imagen
proporciones_congruencia = {
    'B': 0.9,
    'E': 0.8,
    'A': 0.9,
    'F': 0.8,
    'fbE': 1.0,
    'C': 1.0
}

def seleccionar_imagenes(repeticiones):
    lista_imagenes = []
    num_por_imagen = repeticiones // len(imagenes)

    # Añadir cada imagen el número necesario de veces
    for img in imagenes:
        lista_imagenes.extend([img] * num_por_imagen)

    # Barajar la lista de imágenes
    random.shuffle(lista_imagenes)
    return lista_imagenes

def generar_congruencia(total_trials, congruencia_porcentaje):
    """
    Genera una lista determinista de congruencia/incongruencia basada en el porcentaje deseado.
    """
    congruentes = int(total_trials * congruencia_porcentaje)
    incongruentes = total_trials - congruentes

    # Crear la lista con las proporciones exactas
    congruencia_lista = [1] * congruentes + [0] * incongruentes  # 1 = congruente, 0 = incongruente

    # Barajar la lista para aleatorizar el orden
    random.shuffle(congruencia_lista)

    return congruencia_lista

def evaluar_respuesta_bloques_1_2(img, keys, congruencia_lista):
    tecla_registrada = keys[0][0] if keys else "N/A"
    correct = -1
    go_no_go = "N/A"

    if "C.jpg" in img or "F.jpg" in img or "A.jpg" in img:
        correct = 0 if tecla_registrada == "space" else 1
        go_no_go = "no-go"
    elif "E.jpg" in img or "B.jpg" in img or "fbE.jpg" in img:
        correct = 1 if tecla_registrada == "space" else 0
        go_no_go = "go"

    return evaluar_restante(img, correct, go_no_go, keys, congruencia_lista)

def evaluar_respuesta_bloques_3_4(img, keys, congruencia_lista):
    tecla_registrada = keys[0][0] if keys else "N/A"
    correct = -1
    go_no_go = "N/A"

    if "fbE.jpg" in img or "E.jpg" in img or "A.jpg" in img:
        correct = 0 if tecla_registrada == "space" else 1
        go_no_go = "no-go"
    elif "F.jpg" in img or "B.jpg" in img or "C.jpg" in img:
        correct = 1 if tecla_registrada == "space" else 0
        go_no_go = "go"

    return evaluar_restante(img, correct, go_no_go, keys, congruencia_lista)

def evaluar_restante(img, correct, go_no_go, keys, congruencia_lista):
    tecla_registrada = keys[0][0] if keys else "N/A"
    tipo_asociacion = "N/A"
    feedback = -1

    if "C.jpg" in img or "fbE.jpg" in img:
        tipo_asociacion = "100"
        feedback = correct
    elif "B.jpg" in img or "A.jpg" in img:
        tipo_asociacion = "90-10"
        feedback = correct if congruencia_lista.pop(0) == 1 else abs(correct - 1)
    elif "E.jpg" in img or "F.jpg" in img:
        tipo_asociacion = "80-20"
        feedback = correct if congruencia_lista.pop(0) == 1 else abs(correct - 1)

    congruente = 1 if correct == feedback else 0

    print(f"Imagen: {img}, Correct: {correct}, Feedback: {feedback}, Tipo Asociación: {tipo_asociacion}, Go/No-Go: {go_no_go}, Congruente: {congruente}")

    return correct, feedback, tipo_asociacion, go_no_go, tecla_registrada, congruente
    
def ejecutar_bloque(repeticiones, bloque_index=0):
    datos = []
    lista_imagenes = seleccionar_imagenes(repeticiones)

    # Crear un diccionario para almacenar las listas de congruencia por imagen
    from collections import Counter
    congruencia_por_imagen = {}

    # Contar cuántas veces aparece cada imagen base (sin extensión)
    conteo_imagenes = Counter([img.split("\\")[-1].split("/")[-1].split(".")[0] for img in lista_imagenes])

    # Generar una lista de congruencia por imagen según su proporción
    for nombre_imagen, cantidad in conteo_imagenes.items():
        porcentaje = proporciones_congruencia.get(nombre_imagen, 1.0)  # por defecto 100%
        congruencia_por_imagen[nombre_imagen] = generar_congruencia(cantidad, porcentaje)

    # Selección automática de la función de evaluación según el número de bloque
    if bloque_index in [0, 1]:
        evaluar_respuesta = evaluar_respuesta_bloques_1_2
    else:
        evaluar_respuesta = evaluar_respuesta_bloques_3_4

    tarea_start_time = core.getTime() * 1000  # Tiempo inicial de la tarea en milisegundos

    for img in lista_imagenes:
        check_exit()

        # Cruz de fijación
        fixation_start_time = core.getTime() * 1000 - tarea_start_time
        fixation.draw()
        win.flip()
        while core.getTime() * 1000 - tarea_start_time - fixation_start_time < 500:
            pass
        fixation_end_time = core.getTime() * 1000 - tarea_start_time

        check_exit()

        # Mostrar imagen
        imagen_stim.image = img
        imagen_stim.draw()
        win.flip()
        imagen_start_time = core.getTime() * 1000 - tarea_start_time
        keys = event.waitKeys(maxWait=1.0, keyList=["space", "escape"], timeStamped=True)
        imagen_end_time = core.getTime() * 1000 - tarea_start_time

        if keys and keys[0][0] == "escape":
            check_exit()

        tiempo_transcurrido = imagen_end_time - imagen_start_time
        tiempo_restante = max(0, 1000 - tiempo_transcurrido)
        core.wait(tiempo_restante / 1000.0)  # Convertir a segundos

        key_pressed = 1 if keys else 0
        reaction_time = round((keys[0][1] * 1000 - tarea_start_time) - imagen_start_time, 3) if keys else "N/A"
        reaction_time_ms = round((keys[0][1] * 1000 - tarea_start_time), 3) if keys else "N/A"

        # Obtener el nombre base de la imagen (sin extensión)
        nombre_imagen = img.split("\\")[-1].split("/")[-1].split(".")[0]

        # Evaluar la respuesta usando la función seleccionada
        correct, feedback, tipo_asociacion, go_no_go, tecla_registrada, congruente = evaluar_respuesta(
            img, keys, congruencia_por_imagen[nombre_imagen]
        )

        # Mostrar feedback
        feedback_start_time = core.getTime() * 1000 - tarea_start_time
        feedback_stim.text = "Correcto" if feedback == 1 else "Incorrecto"
        feedback_stim.draw()
        win.flip()
        while core.getTime() * 1000 - tarea_start_time - feedback_start_time < 500:
            pass
        feedback_end_time = core.getTime() * 1000 - tarea_start_time

        # Guardar datos del ensayo
        datos.append([datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"), "Tarea TFM", psychopy.__version__,
                      60, 60, datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"), nombre, edad, img.split("/")[-1],
                      round(fixation_start_time, 3), round(fixation_end_time, 3), round(imagen_start_time, 3),
                      round(imagen_end_time, 3), round(feedback_start_time, 3), round(feedback_end_time, 3),
                      key_pressed, reaction_time_ms, reaction_time, correct, feedback,
                      tipo_asociacion, go_no_go, tecla_registrada, congruente])

    return datos

def ejecutar_ensayo_20_trials():
    """
    Ejecuta un ensayo inicial con 20 trials siguiendo la lógica de los bloques 1 y 2.
    """
    print("Iniciando el ensayo con 20 trials...")
    ensayo_datos = []
    lista_imagenes = seleccionar_imagenes(20)  # Solo 20 imágenes para el ensayo

    # Crear un diccionario para almacenar las listas de congruencia por imagen
    from collections import Counter
    congruencia_por_imagen = {}

    # Contar cuántas veces aparece cada imagen base (sin extensión)
    conteo_imagenes = Counter([img.split("\\")[-1].split("/")[-1].split(".")[0] for img in lista_imagenes])

    # Generar una lista de congruencia por imagen según su proporción
    for nombre_imagen, cantidad in conteo_imagenes.items():
        porcentaje = proporciones_congruencia.get(nombre_imagen, 1.0)  # por defecto 100%
        congruencia_por_imagen[nombre_imagen] = generar_congruencia(cantidad, porcentaje)

    # Usar la lógica de los bloques 1 y 2
    evaluar_respuesta = evaluar_respuesta_bloques_1_2

    tarea_start_time = core.getTime() * 1000  # Tiempo inicial de la tarea en milisegundos

    for img in lista_imagenes:
        check_exit()

        # Cruz de fijación
        fixation_start_time = core.getTime() * 1000 - tarea_start_time
        fixation.draw()
        win.flip()
        while core.getTime() * 1000 - tarea_start_time - fixation_start_time < 500:
            pass
        fixation_end_time = core.getTime() * 1000 - tarea_start_time

        check_exit()

        # Mostrar imagen
        imagen_stim.image = img
        imagen_stim.draw()
        win.flip()
        imagen_start_time = core.getTime() * 1000 - tarea_start_time
        keys = event.waitKeys(maxWait=1.0, keyList=["space", "escape"], timeStamped=True)
        imagen_end_time = core.getTime() * 1000 - tarea_start_time

        if keys and keys[0][0] == "escape":
            check_exit()

        tiempo_transcurrido = imagen_end_time - imagen_start_time
        tiempo_restante = max(0, 1000 - tiempo_transcurrido)
        core.wait(tiempo_restante / 1000.0)  # Convertir a segundos

        key_pressed = 1 if keys else 0
        reaction_time = round((keys[0][1] * 1000 - tarea_start_time) - imagen_start_time, 3) if keys else "N/A"
        reaction_time_ms = round((keys[0][1] * 1000 - tarea_start_time), 3) if keys else "N/A"

        # Obtener el nombre base de la imagen (sin extensión)
        nombre_imagen = img.split("\\")[-1].split("/")[-1].split(".")[0]

        # Evaluar la respuesta usando la lógica de los bloques 1 y 2
        correct, feedback, tipo_asociacion, go_no_go, tecla_registrada, congruente = evaluar_respuesta(
            img, keys, congruencia_por_imagen[nombre_imagen]
        )

        # Mostrar feedback
        feedback_start_time = core.getTime() * 1000 - tarea_start_time
        feedback_stim.text = "Correcto" if feedback == 1 else "Incorrecto"
        feedback_stim.draw()
        win.flip()
        while core.getTime() * 1000 - tarea_start_time - feedback_start_time < 500:
            pass
        feedback_end_time = core.getTime() * 1000 - tarea_start_time

        # Guardar datos del ensayo
        ensayo_datos.append([datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"), "Ensayo TFM", psychopy.__version__,
                             60, 60, datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"), nombre, edad, img.split("/")[-1],
                             round(fixation_start_time, 3), round(fixation_end_time, 3), round(imagen_start_time, 3),
                             round(imagen_end_time, 3), round(feedback_start_time, 3), round(feedback_end_time, 3),
                             key_pressed, reaction_time_ms, reaction_time, correct, feedback,
                             tipo_asociacion, go_no_go, tecla_registrada, congruente])

    return ensayo_datos

try:
    # Mostrar las imágenes iniciales
    mostrar_imagenes_iniciales(imagenes_introductorias)

    # Mostrar texto para el ensayo
    texto_ensayo = visual.TextStim(
        win, 
        text="Vamos a comenzar con un breve ensayo.", 
        color=(-1, -1, -1), height=30
    )
    texto_ensayo.draw()
    win.flip()
    if "escape" in event.waitKeys(keyList=["space", "escape"]):
        check_exit()

    # Ejecutar el ensayo inicial con 20 trials
    datos_ensayo += ejecutar_ensayo_20_trials()

    # Mostrar texto después del ensayo
    texto_post_ensayo = visual.TextStim(
        win, 
        text="¡Muy bien! Ahora que has comprendido la tarea, vamos a realizar la prueba. Pulsa la barra espaciadora cuando estés preparado para comenzar.", 
        color=(-1, -1, -1), height=30
    )
    texto_post_ensayo.draw()
    win.flip()
    if "escape" in event.waitKeys(keyList=["space", "escape"]):
        check_exit()

    # Ejecutar los bloques principales
    for bloque_index in range(4):  # Ciclo para los 4 bloques
        # Mostrar las imágenes "4.jpg" y "5.jpg" antes del bloque 3
        if bloque_index == 2:
            imagenes_transicion = [
                r"C:\Users\navar\Desktop\tarea tfm\reversal\Copia de INHIBICIÓN COGNITIVA\4.jpg",
                r"C:\Users\navar\Desktop\tarea tfm\reversal\Copia de INHIBICIÓN COGNITIVA\5.jpg"
            ]
            for imagen in imagenes_transicion:
                transition_image = visual.ImageStim(win, image=imagen)
                transition_image.draw()
                win.flip()
                if "escape" in event.waitKeys(keyList=["space", "escape"]):
                    check_exit()

        # Ejecutar el bloque con 102 ensayos
        datos_principales += ejecutar_bloque(102, bloque_index=bloque_index)

        if bloque_index < 3:
            descanso_text = visual.TextStim(
                win, 
                text="Tómate un descanso, y cuando estés preparado para seguir, pulsa la barra espaciadora", 
                color=(-1, -1, -1), height=30
            )
            descanso_text.draw()
            win.flip()
            if "escape" in event.waitKeys(keyList=["space", "escape"]):
                check_exit()

    # Mostrar el texto final
    final_text = visual.TextStim(
        win, 
        text="¡Has terminado con la tarea! Muchas gracias por participar.", 
        color=(-1, -1, -1), height=30
    )
    final_text.draw()
    win.flip()
    if "escape" in event.waitKeys(keyList=["space", "escape"]):
        check_exit()

except Exception as e:
    print(f"Error durante la tarea: {e}")
finally:
    guardar_datos()
    win.close()
